= elf-load-analyse =
 *工具 file ldd strace
 *内存分配两阶段
  *execve()中 有ld
  *execve()后 系统调用动态链接库 
 *论文是内核转载的部分
 
== 相关的源码 ==
 *sys_execve()
 *do_execve()
 *prepare_binprm()
== 相关内容 ==
 1. bash shell “fork”一个与自身一模一样的 process。
该 process 执行系统调用 execve(),也就是你看到的 strace 输出的第一行
execve("./hello", ["./hello"], [/* 22 vars */]) = 0。由于无论是读取文件,还是文件映
射(File Mapping)都发生在 Kernel 里,所以 strace 不能监控到这一步的任何东
西。本文要分析的即是该过程。
 2. 系统调用 execve()以后, process 的真正入口被设置成动态链接器的入口该(如
果是静态链接的话,就比较简单,设置的入口就是该可执行文件 hello 的入口).
当该新 process 返回到用户态(也就是从 execve 执行完后从内核态返回到用户态,不是对该函数调用的返回。因为只有该函数调用失败才会有返回,成功的话,就进入了另一个“世界”,控制转移到动态链接器(/lib/ld-2.3.4.so))。
== 函数地址 ==
 */arch/i386/kernel/process.c: * sys_execve() executes a new program. asmlinkage int sys_execve(struct pt_regs regs)
 */fs/exec.c: * sys_execve() executes a new program.
== sys_execve() ==
{{{#! cplusplus
/*
 * sys_execve() executes a new program.
 */
asmlinkage int sys_execve(struct pt_regs regs)
{
	int error;
	char * filename;

	filename = getname((char __user *) regs.ebx);
	error = PTR_ERR(filename);
	if (IS_ERR(filename))
		goto out;
	error = do_execve(filename,
			(char __user * __user *) regs.ecx,
			(char __user * __user *) regs.edx,
			&regs);
	if (error == 0) {
		current->ptrace &= ~PT_DTRACE;
		/* Make sure we don't return using sysenter.. */
		set_thread_flag(TIF_IRET);
	}
	putname(filename);
out:
	return error;
}
}}}
== sys_execve()注释 ==
{{{#! cplusplus
/*
 * sys_execve() executes a new program.
 */
asmlinkage int sys_execve(struct pt_regs regs) 用寄存器来传 这么来的 这是包装的函数
{
	int error;
	char * filename;

	filename = getname((char __user *) regs.ebx);有使用内核空间 是怎么回事
	error = PTR_ERR(filename);
	if (IS_ERR(filename))
		goto out;
	error = do_execve(filename, 处理的
			(char __user * __user *) regs.ecx, 这是什么类型
			(char __user * __user *) regs.edx,
			&regs);
	if (error == 0) {单处理器
		current->ptrace &= ~PT_DTRACE;
		/* Make sure we don't return using sysenter.. */ 什么意思
		set_thread_flag(TIF_IRET); 什么用
	}
	putname(filename);
out:
	return error; 成功的话 还有用吗
}
}}}
== do_execve() ==
{{{#! cplusplus
/*
 * sys_execve() executes a new program.
 */
int do_execve(char * filename,
	char __user *__user *argv,
	char __user *__user *envp,
	struct pt_regs * regs)
{
	struct linux_binprm bprm;
	struct file *file;
	int retval;
	int i;

	file = open_exec(filename);

	retval = PTR_ERR(file);
	if (IS_ERR(file))
		return retval;

	sched_balance_exec();

	bprm.p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);
	memset(bprm.page, 0, MAX_ARG_PAGES*sizeof(bprm.page[0]));

	bprm.file = file;
	bprm.filename = filename;
	bprm.interp = filename;
	bprm.sh_bang = 0;
	bprm.loader = 0;
	bprm.exec = 0;
	bprm.security = NULL;
	bprm.mm = mm_alloc();
	retval = -ENOMEM;
	if (!bprm.mm)
		goto out_file;

	retval = init_new_context(current, bprm.mm);
	if (retval < 0)
		goto out_mm;

	bprm.argc = count(argv, bprm.p / sizeof(void *));
	if ((retval = bprm.argc) < 0)
		goto out_mm;

	bprm.envc = count(envp, bprm.p / sizeof(void *));
	if ((retval = bprm.envc) < 0)
		goto out_mm;

	retval = security_bprm_alloc(&bprm);
	if (retval)
		goto out;

	retval = prepare_binprm(&bprm);
	if (retval < 0)
		goto out;

	retval = copy_strings_kernel(1, &bprm.filename, &bprm);
	if (retval < 0)
		goto out;

	bprm.exec = bprm.p;
	retval = copy_strings(bprm.envc, envp, &bprm);
	if (retval < 0)
		goto out;

	retval = copy_strings(bprm.argc, argv, &bprm);
	if (retval < 0)
		goto out;

	retval = search_binary_handler(&bprm,regs);
	if (retval >= 0) {
		free_arg_pages(&bprm);

		/* execve success */
		security_bprm_free(&bprm);
		return retval;
	}

out:
	/* Something went wrong, return the inode and free the argument pages*/
	for (i = 0 ; i < MAX_ARG_PAGES ; i++) {
		struct page * page = bprm.page[i];
		if (page)
			__free_page(page);
	}

	if (bprm.security)
		security_bprm_free(&bprm);

out_mm:
	if (bprm.mm)
		mmdrop(bprm.mm);

out_file:
	if (bprm.file) {
		allow_write_access(bprm.file);
		fput(bprm.file);
	}
	return retval;
}
}}}
== do_execve()注释 ==
{{{#! cplusplus
/*
 * sys_execve() executes a new program.
 */
int do_execve(char * filename,
	char __user *__user *argv,
	char __user *__user *envp,
	struct pt_regs * regs)
{
	struct linux_binprm bprm;
	struct file *file;
	int retval;
	int i;

	file = open_exec(filename);

	retval = PTR_ERR(file);
	if (IS_ERR(file))
		return retval;

	sched_balance_exec();

	bprm.p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);
	memset(bprm.page, 0, MAX_ARG_PAGES*sizeof(bprm.page[0]));

	bprm.file = file;
	bprm.filename = filename;
	bprm.interp = filename;
	bprm.sh_bang = 0;
	bprm.loader = 0;
	bprm.exec = 0;
	bprm.security = NULL;
	bprm.mm = mm_alloc();
	retval = -ENOMEM;
	if (!bprm.mm)
		goto out_file;

	retval = init_new_context(current, bprm.mm);
	if (retval < 0)
		goto out_mm;

	bprm.argc = count(argv, bprm.p / sizeof(void *));
	if ((retval = bprm.argc) < 0)
		goto out_mm;

	bprm.envc = count(envp, bprm.p / sizeof(void *));
	if ((retval = bprm.envc) < 0)
		goto out_mm;

	retval = security_bprm_alloc(&bprm);
	if (retval)
		goto out;

	retval = prepare_binprm(&bprm);
	if (retval < 0)
		goto out;

	retval = copy_strings_kernel(1, &bprm.filename, &bprm);
	if (retval < 0)
		goto out;

	bprm.exec = bprm.p;
	retval = copy_strings(bprm.envc, envp, &bprm);
	if (retval < 0)
		goto out;

	retval = copy_strings(bprm.argc, argv, &bprm);
	if (retval < 0)
		goto out;

	retval = search_binary_handler(&bprm,regs);
	if (retval >= 0) {
		free_arg_pages(&bprm);

		/* execve success */
		security_bprm_free(&bprm);
		return retval;
	}

out:
	/* Something went wrong, return the inode and free the argument pages*/
	for (i = 0 ; i < MAX_ARG_PAGES ; i++) {
		struct page * page = bprm.page[i];
		if (page)
			__free_page(page);
	}

	if (bprm.security)
		security_bprm_free(&bprm);

out_mm:
	if (bprm.mm)
		mmdrop(bprm.mm);

out_file:
	if (bprm.file) {
		allow_write_access(bprm.file);
		fput(bprm.file);
	}
	return retval;
}
}}}
