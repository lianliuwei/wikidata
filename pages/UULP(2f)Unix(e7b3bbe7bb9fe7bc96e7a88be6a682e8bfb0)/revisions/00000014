= Unix系统编程概述 =
 *从分析操作系统->相关程序->Unix命令->系统调用->自己编程
 *看软件的不同角度：用户级 系统级 理论级 代码级 ....
 *实例的方法
 *模型很是重要 有模型才能进行解释 才能进行理解
 *图很是重要 容易了解 黑箱模型
 *资源的有限 和 代码的重复 产生了操作系统
 *操作系统是特殊的程序
 *操作系统是服务
 *内存和其他设备有不一样 每个进程独立 不用申请
 *操作系统即管理资源 使得有规有据的使用各种资源
 *程序是如何和其他系统部分进行交互 通过Kernel
 *系统编程 使用系统提供的服务
 *系统角度 程序是如何使用系统资源的 bc和dc的例子
 *分析程序－>学习系统调用—>编程实现
 *shell即是暴露的人机接口
 *人和一的shell绑定 shell控制了人
 *文件系统就是一奇迹 从树到硬盘
 *网络也是一奇迹 将很多的计算机连接到一起
 *Unix系统编程重要方面 通信 协作 网络访问
 *WWW是最大的分布式系统
 *了解历史发展很重要
 *将函数看成是不同的抽象 来理解
 *现实中 标准和兼容性 对模型的影响很大
 *从提供服务 和 资源 来看操作系统 了解操作系统 和 其哲学
== 系统资源 ==
 *学习内容 了解资源 使用资源 设置资源
 *处理器 执行 暂停 恢复 终止 大部分由系统执行
 *I/O 用申请模型
 *进程管理 处理器的抽象 资源集合的概念 后来加入了线程来表示执行过错 进程用来表示资源
 *内存 每进程独立 有时需要共享
 *设备 驱动 同一接口 命名
 *计时器 时间的概念
 *IPC 沟通的方式 模拟现实
 *网络 IPC的特殊形式 但是极其庞大
== more ==
=== 外部观察 ===
 *少于一屏幕 显示后直接退出
 *多余屏幕 会显示反白的提示 按下q退出 空格下一个全屏幕 回车下一行 输入是不需要回车的 输入也不回显
 *可以从标准输入 输入
=== 分析 ===
 *more 不管是 文件数据 还是 标准输入 的数据 都是要更具终端的输入(即是用户的输入)进行显示
 */dev/tty 可能打开的是对应于这程序远行的现在的tty的文件 非固定 和程序有关
 *输入时后
=== 实现 ===
 *esc(\033) [ 数字 m   改变终端的字符属性 这是终端时代留下来的产物 
 *1.1 和 1.2 是对应的程序
 *1.2可以使用管道
 
