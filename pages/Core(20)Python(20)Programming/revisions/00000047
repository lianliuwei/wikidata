= Core Python Programming =
{{{#!wiki
<<TableOfContents(3)>>
 *看到 597
 *做练习 
 *[[http://www.china-pub.com/39969|目录]]
 *[[http://wiki.woodpecker.org.cn/moin/CorePyProgramming|翻译组织官网]]
== Part I: Core Python ==
=== 欢迎来到Python世界 ===
 *.py是Python的扩展名
 *.pyc .pyo是编译完的文件
 *#!/bin/env python 可以用于选择python的位置，不知这是什么原理
 *标准版本的 Python 是用 C 来编译的， 又叫 CPython
 *Stackless
=== Python起步 ===
 *分语句和表达式
 *使用空格当做代码块
 *print后加，表示不换行 但是会自动添加空格
 *Python Enhancement Proposal
=== Python基础 ===
 * 继续( \ )，也有不用就可以直接换行的语句
 *复合语句首行以关键字开始，以冒号( : )结束
 *代码组由不同的缩进分隔
 *没有缩进的代码块是最高层次的，别称做脚本的“main”部分
 *同一行书写多个语句(;)
 *每一个 Python 脚本文件都可以被当成是一个模块
 *赋值语句不会返回值 但是 链式赋值没问题
 *对象是通过引用传递的
 *Python 不支持类似 x++ 或 --x 这样的前置/后置自增/自减运算
 *“多元”赋值
 *多元赋值方式可以实现无需中间变量交换两个变量的值
  *_xxx    不用'from module import *'导入  私有的
  * __xxx__系统定义名字 
  *__xxx   类中的私有变量名
 *可以用属性 obj.__doc__来访问标准注释
 *大部分的Python 模块都是用于导入调用的，直接运行模块 应该调用该模块的回归测试代码。 
 *如果模块是被导入， __name__ 的值为模块名字  如果模块是被直接执行， __name__ 的值为 '__main__'
 *在主程序中放置测试代码是测试模块的简单快捷的手段。
 *unittest 模块， 有时候它被称为 PyUnit, 是一个测试框架。大系统的组件进行正规系统的回规测试可以使用
 *变量和内存管理
  *变量无须指定类型 
  *程序员不用关心内存管理 
  *变量名会被“回收” 
  *del 语句能够直接释放资源
 *使用引用就不会造成C中指针的空指针和引用在对象被删除的情况
 *技巧：使用局部变量替换模块变量
 *异常处理最适用的场合，是在没有合适的函数处理异常状况的时候
 *Debugger: pdb 
 *Logger: logging 
 *Profilers: profile, hotshot, cProfile 
=== Python对象 ===
 *Python 对象 
  *身份 使用内建函数id()来得到 可以被认为是该对象的内存地址
  *类型 用内建函数 type()查看 Python 对象的类型 type()返回的也是对象
  *值
 *其他内建类型
  *所有类型对象的类型都是 type，它也是所有 Python 类型的根和所有 Python 标准类的默认元类（metaclass）
  *NoneType类只有一个值， 那就是 None
  *对象的布尔值是 False 
   *None 
   *False (布尔类型) 
   *所有的值为零的数
  *python虚拟机会缓冲整数常量
 *内部类型
  *代码对象
  *帧对象　
  *跟踪记录对象　
  *切片对象　
  *省略对象　
  *XRange 对象 
 *标准类型内建函数　
  *type（）　
  *cmp（）　
  *str（）和repr（）（及``操作符）
   *eval（）可以用reper（）和``来获得原始对象
  *type（）和isinstance（）　
   *types包里有常用type的类型
  *Python类型操作符和内建函数总结
 *类型工厂函数
 *标准类型的分类　
  *存储模型
  *更新模型
  *访问模型
 *不支持的类型
  *仅需要使用一种类型， 就是 Python 的整型
  *Decimals 则拥有任意的精度。在处理金钱这类确定的值时， Decimal 类型就很有用
=== 数字 ===
 *数字类型
  *变更数字的值会生成新的对象
  *变量像一个指针指向装变量值的盒子
  *删除一个数值对象的引用， 使用 del 语句
 *整型
  *布尔型 只有True和False两个值
  *标准整数类型 
  *长整型 Python 的长整数类型能表达的数值仅仅与你的机器支持的(虚拟)内存大小有关 用大写字母 “L”表示长整数
  *双精度浮点数
  *复数 复数带有属性
 *运算符
  *类型转换的基本原则是： 整数转换为浮点数， 非复数转换为复数
  *位运算符（只适用于整数） 
 *内建函数与工厂函数 
  *标准类型函数 cmp(), str() 和 type()
  *数字类型函数
   *函数 int(), long(), float() complex() bool()
   *这些内建函数都是类对象 表5.5关于这些函数
   *Python 有五个运算内建函数用于数值运算： abs(), coerce(), divmod(), pow(), pow(),round()
  *仅用于整数的函数
   *进制转换函数 oct()和 hex()
   *ASCII 转换函数 chr()和ord()
 *其他数字类型
  *在数学运算中，Boolean 值的 True 和 False 分别对应于 1 和 0
  *十进制浮点数 
 *相关模块 
  *[[http://numeric.scipy.org/]]
  *[[http://scipy.org/]]
  *decimal 
  *array 
  *math/cmath
  *operator 
  *random
 *表 5.9 总结
=== 映像和集合类型 ===
 * 序列
  *为-N - N-1范围
  *成员关系操作符 (in, not in) 
  *切片操作符 ( [], [:], [::] ) 
  *重复操作符 ( * ) 
  *连接操作符( + ) 
  *s[::-1] # 可以视作"翻转"操作 
  *开始和结束素引值可以超过字符串的长度
  *内建函数 list(),str()和 tuple()被用做在各种序列类型之间转换 这些转换实际上是工厂函数 将对象作为参数，并将其内容（浅）拷贝到新生成的对象中
 *字符串
  *双引号和单引号在 Python 里面被视作一样
  *没有字符这个类型
  *从性能的的角度来考虑，把重复操作作为参数放到循环里面进行是非常低效的
  *使用字符串格式化操作符(%)提高性能
  *如果把一个普通字符串和一个 Unicode 字符串做连接处理，Python 会在连接操作前先把普通字符串转化为 Unicode 字符串
  *表 6.4 字符串格式化符号
  *可以使用元组和字典类型作为参数
  *字符串模板
  *原始字符串操作符( r/R ) 
  *Python里面没有C风格的结束字符NUL
  *三引号
 *Unicode
  *真正的对象ASCII 字符串成了 String Type，而 Unicode 字符串成了Unicode Type 类型
  *string 模块已经停止了更新
  *内建的 str()函数和 chr()函数并没有升级成可以处理 Unicode
  *codec是COder/DECoder的首字母组合
  *每当你向一个文件写入字符串的时候，你必须定义一个编码(encoding 参数)
  *除了 pickle 模块 都兼容unicode
  *表 6.10 列出了 Python 标准库里面与字符串有关的主要模块
 *列表
  *extend()方法的一个优点是它实际上是把新列表添加到了原有的列表里面,而不是像连接操作那样新建一个列表
  *列表解析
  *6.13.1列表比较算法
  *len() max() and min() sorted() and reversed() enumerate() and zip()
  *list() and tuple() 接受可迭代对象(比如另一个序列)作为参数,并通过浅拷贝数据来创建一个新的列表或者元组
  *那些可以改变对象值的可变对象的方法是没有返回值的
  *sort()方法,它默认的排序算法是归并排序(或者说"timsort")的衍生算法
  *用列表构建其他数据结构 
   *堆栈 队列
 *元组 
  *用的是圆括号而列表用的是方括号 不可变类型 用做一个字典的key
  *把数据传给一个不了解的 API 时，可以确保我们的数据不会被修改
  *集合默认的类型都是元组
  *总是显式的用圆括号表达式表示元组或者创建一个元组
  *使用('xyz',)来创建单元组 
  *Table 6.12  与序列类型相关的模块
 *拷贝Python对象、浅拷贝和深拷贝　
  *copy()进行浅拷贝操作,而 deepcopy()进行深拷贝操作
 *总结
=== 映像和集合类型 ===
 *映射类型：字典
  *内建方法 fromkeys() 来创建一个"默认"字典
  *keys()方法获取供循环使用的键值列表
  *字典中的键不允许被改变
  *用字典参数可以简化 print 语句
  *避免使用内建对象名字作为变量的标识符
  *不支持像拼接（concatenation）和重复(repetition)这样的操作
  *键是参数(argument), 而不是一个索引(index)
  *字典比较算法 
  *从已存在的字典生成新的字典速度比用 copy()方法慢
  *只有这个对象是可哈希的，才可作为字典的键
  *不允许一个键对应多个值
  *实现了__hash__() 特殊方法的类 可以做为键
  *元组中只包括像数字和字符串这样的不可变参数，才可以作为字典中有效的键
 *集合类型
  *frozenset 和 set
  *表 7.3 集合操作符和关系符号
  *如果左右两个操作数的类型不相同则所产生的结果类型与左操作数的类型相同
  *在使用内建方法时，对象也可以是迭代类型的
  *7.6 中总结了所有的集合类型的操作符、函数和方法
=== 条件和循环 ===
 *Python 的缩进使用强制使代码正确对齐, 让程序员来决定 else 属于哪一个 if
 * if 语句后最多只能有一个 else 语句, 但可以有任意数量的 elif 语句
 *条件表达式(即"三元操作符")  
  *X if C else Y 等同于 (x < y and [x] or [y])[0] 
 *for 语句
  *可以遍历序列成员, 可以用在 列表解析 和 生成器表达式中, 它会自动地调用迭代器的 next() 方法, 捕获 StopIteration 异常并结束循环(所有这一切都是在内部发生的)
  *像是 shell 或是脚本语言中的 foreach 循环
 *xrange() 类似 range() , 不过当有一个很大的范围列表时, xrange() 可能更为适合, 因为它不会在内存里创建列表的完整拷贝
 *与序列相关的内建函数 sorted(), reversed(), enumerate(), zip()
 *pass 语句 表示空操作
 *可以在 while 和 for 循环中使用 else 语句. 在循环中使用时, else 子句只在循环完成后执行
 *迭代器就是有一个 next() 方法的对象
 *文件对象生成的迭代器会自动调用 readline() 方法
 *在迭代可变对象的时候修改它们并不是个好主意
 *一个实现了 __iter__() 和 next() 方法的类可以作为迭代器使用
 *列表解析
 *生成器表达式 
 *重构样例 很好的展现了列表解析和生成器的优势
=== 文件和输入输出 ===
 *使用文件的概念处理很多操作
 *open()和file()返回文件对象
 *open()是从C语言的fopen()中衍生出来的
 *提供UNS 对通用换行符的支持
 *四类操作：输入 输出 文件内移动 杂项
 *read() readline() readlines()
 *write() writelines()
 *不会自动添加或删除行结束符
 *seek() text()
 *不是用文件对象的时候要显示的关闭 不然会丢失缓冲区数据
 *flush() isatty() truncate()
 *使用os模块的属性确定对应平台的分隔符和换行符
 *表 9.3 文件对象的内建方法列表 
 *表 9.4 文件对象的属性 
 *和Unix的设计一样，一启动就有3个文件
 *使用sys模块的 sys.stdin , sys.stdout 和 sys.stderr 访问
 *使用sys.argv来获得命令行传输 sys.argv[0] 永远是程序的名称
 *getopt optparse模块用于选项的解析
 *访问文件系统需要使用os模块 os模块会加载posix nt mac dos os2等模块
 *表 9.5 os块的文件/目录访问函数 
 *表 9.6 os.path 模块中的路径名访问函数
 *存储Python对象：pickle 和 marshal 模块
 *cPickle 是 pickle 的一个更快的 C 语言编译版本 
 *dbhash/bsddb, dbm,   gdbm,  以及  dumbdbm用来存储字符串 可能是用数据库存储
 *shelve模块 提供对前两种的支持 
 *9.10 相关模块
=== 错误和异常 ===
 *源于对操作系统的模拟
 *SyntaxError是唯一不是在运行时发生的异常
 *使用try-except-finally语句 else子句用于没有探测到异常时执行代码
 *pass关键字 忽略异常
 *处理多种异常可以使用多个except语句 或者异常元组
 *使用Exception类可以捕获所有的异常
 *with用来支持 上下文管理 相应对象要支持上下文管理协议 参考contextlib模块
 *raise语句来触发异常
 *assert语句来实现断言
 *Python内建了很多标准异常
 *可以使用sys.exc_info()来获得异常三元组
=== 函数和函数式编程 ===
 *没有返回时，解释器会默认返回None
 *利用元组的不一定带圆括号的特性，代码可以看出返回多个值
 *关键字参数 让调用者通过函数调用中的参数名字来区分参数
 *默认参数 声明了默认值的参数
 *使用*元组 可以使用元组作为函数的参数
  *使用**字典 可以使用字典作为函数的参数
 *使用def关键字来创建函数
 *函数可以加一个文档字串
 *没有前向引用的问题
 *使用句点来解决名字冲突
 *函数属性使得函数看起来像是一个对象 是个函数对象
 *可以定义内部/内嵌函数
 *闭包：内部函数的定义包含了在外部函数里定义的对象的引用（这个对象甚至可以是在外部函数之外）
 *装饰器：对方法进行修饰 如 类方法声明为静态方法
 *装饰器实际上就是函数
 *和AOP概念有关
 *函数的唯一不同是可以调用
 *函数对象的引用和函数对象的调用
 *变长参数：非关键字可变长参数 关键字变量参数
 *lambda匿名函数 只能是一行
 *对函数式编程有模仿
 *PFA：偏函数应用 使用partial()
 *参考[[http://kb.cnblogs.com/a/1588265/|Lambda演算与科里化(Currying)]]
 *相关内部函数：apply() filter() map() reduce()
 *使用global关键字可以将全局范围变量内引入局部范围
 *支持静态嵌套作用域
 *使用函数的func_closure可以来访问函数的闭包变量
 *生成器 使用yield语句
 *使用send()可以像生成器传值 使用close()可以关闭生成器
=== 模块 ===
 *模块是用来组织 Python 代码的方法, 而包则是用来组织模块的
 *模块是按照逻辑来组织 Python 代码的方法, 文件是物理层上组织模块的方法
 *搜索路径修改 启动Python的shell或命令行的PYTHONPATH环境变量 sys模块的sys.path变量
 *使用sys.modules可以找到当前导入了哪些模块和它们来自什么地方
 *动态更改命名空间 改变一个名字的绑定叫做重新绑定  删除一个名字叫做解除绑定
 *执行期间有两个或三个活动的名称空间 局部名称空间 全局名称空间 内建名称空间
 *Python 解释器首先加载内建名称空间。 它由 __builtins__ 模块中的名字构成
 *使用import语句可以导入模块
 *使用from import语句导入模块中的属性
 *使用from import as语句可以导入的同时指定局部绑定名称
 *一个模块只被加载一次, 无论它被导入多少次
 *只从模块导入名字的另一个副作用是那些名字会成为局部名称空间的一部分，对这些变量的改变只影响它的局部拷贝而不是所导入模块的原始名称空间
 *from __future__ import new_feature 导入新特性
 *从 ZIP 文件中导入模块 
 *使用导入钩子可以创建自己的导入器 需要两个类: 查找器 载入器
 *import 语句调用 __import__() 函数完成它的工作
 *调用 import sys 语句等同于sys = __import__('sys')
 *globals() 和 locals() 内建函数分别返回调用者全局和局部名称空间的字典
 *reload()内建函数可以重新导入一个已经导入的模块
 *包是一个有层次的文件目录结构, 它定义了一个由模块和子包组成的 Python 应用程序执行环境
 *包使用 __init__.py 文件作为初始化模块
 *所有的导入现在都被认为是绝对的
 *相对导入：from .Analog import dial from ..common_util import setup
 *sys.modules 变量包含一个由当前载入(完整且成功导入)到解释器的模块组成的字典
 *不让某个模块属性被 "from module import *" 导入 , 可以给不想导入的属性名称加上一个 _ 
 *# -*- coding: UTF-8 -*- 指定源文件编码
 *导入循环会出现错误，而且很隐蔽
=== 面向对象编程 ===
 *类和类实例
 *使用
{{{#!wiki
 class ClassName(bases): 
    'class documentation string' #'类文档字符串' 
     class_suite #类体 
}}}
 语句进行类定义
 *使用myFirstObject = MyNewObjectType()进行创建
 *类可以仅用作名称空间（namespaces）
 *pass语句表示没有任何操作
 *使用self最为第一个参数的类方法要使用类实例进行调用
 *__init__()类初始化
 *子类__init__()中需要显示调用父类的__init__()
 *类名通常由大写字母打头
 *属性和方法使用骆驼记法的下划线方式
 *所有的类属性都是公开的
 *支持反射
 *类是对象
 *类的属性相当于static属性
 *方法带self的需要绑定类实例
 *方法是类固有的属性
 *__dict__属性包含一个字典
 *__new__()类构造器
 *__del__()类解构器
 *实例仅拥有数据属性
 *__init__()应当返回 None
 *实例的特殊属性 __class__ __dict__
 *最好不要修改__dict__
 *内建类型中不存在__dict__
 *可用类来访问类属性，如果实例没有同名的属性，也可用实例来访问，但是更改会产生一个同名的实例属性
 *静态方法和类方法要使用staticmethod()和classmethod()内建函数 或使用函数修饰符
 *文档字符串对类，函数/方法，模块来说都是唯一的，所以特殊属性__doc__不会从基类中继承过来
 *super()方法也可用来调用父类的方法 使用super()的漂亮之处在于不需要明确给出任何基类名字
 *Python 允许子类继承多个基类
 *issubclass() 布尔函数判断一个类是另一个类的子类或子孙类
 *isinstance() 布尔函数在判定一个对象是否是另一个给定类的实例
 *hasattr(), getattr(),setattr(), delattr() 
 *super()
 *vars()
 *特殊方法定制类
  *表 13.4
  *加分还分好多种
 *Python 不允许用多个签名重载可调用对象
 *双下划线(__)开头的属性会被混淆
 *简单的模块级私有化只需要在属性名前使用一个单下划线字符
 *委托
  *实现授权的关键点就是覆盖__getattr__()方法
 *所有原来的 Python 内建的 “casting” 或转换函数现在都是工厂函数
 *__slots__类属性 限制子类添加属性
 *描述符 __get__() __set__()方法
 *属性使用 property()内建函数 可以控制对属性的访问
 *元类让你来定义某些类是如何被创建的
 *元类(通常)传递三个参数(到构造器):类名，从基类继承数据的元组，和(类的)属性字典
 *元类使用__metaclass_进行设定
=== 执行环境 ===
 *运行程序的多种方法
 *可调用对象
  *函数
   *内建函数
   *用户定义函数
  *方法 类中定义的
   *内建方法
   *用户定义的方法
  *类
  *一些类的实例 实现__call__()定义的实例可调用
 *代码对象
 *callable()
 *compile() 'eval' 'single' 'exec'三种
 *eval() 对表达式求值
 *exec语句
  *使用文件对象 执行后会设置标尺到最后，不调用seek()不能重新调用
 *input() 等价于 eval(raw_input())
 *执行其他程序
  *execfile()用来执行其他的Python脚本
  *使用python -m 来执行模块
  *使用os模块里的函数来执行其他程序
  *os.system() 以系统命令方式执行
  *os.popen() 使用管道更改其标准输入输出
  *os.fork() os.exec*() os.wait*()
  *os.spawn*()
  *subprocess模块
  *sys.exit() 引发systemExit异常
  *sys.exitfunc() 没有定义 用户可以自己定义 增加退出调用函数功能 
  *os._exit() 系统级别的退出 最好不要用
 *Table 14.8  os模块函数 
== Part II: Advanced Topics ==
=== 正则表达式 ===
=== 网络编程 ===
=== 网络客户端编程 ===
=== 多线程编程 ===
=== 图形用户界面编程 ===
=== Web 编程 ===
=== 数据库编程 ===
=== 扩展 Python ===
=== 其它话题 ===
}}}
