= TCPL =
== 至读者 ==
 *作者本人以为C++很好
== C++ 概览 ==
 *支持编程方法
  *过程式程序设计
  *模块程序设计
   *单实例的情况下好用
  *数据抽象
   *虚函数很重要
  *面向对象程序设计
  *通用型程序设计
   *通用型容器
   *通用型算法
== 名字空间和异常 ==
 *编译依赖要尽量减少
  *4种解决方法
  *间一致性检查放到链接阶段
 *接口 和 实现 两种界面
 *名字空间用于将名字分布于不同的逻辑空间中，但是冲突会导致使用上的困难
 *名字空间定义倾向于单层次，和Java的多层次有所不同
 *使用使用指令 和 使用声明来组合和选择名字空间
 *特殊用法 无名名字空间 和 名字空间别名
 *C++的异常和Java相比没有finally关键字，也不用什么抛出什么异常
 *不知道异常是怎么实现的
 *异常将错误发生点和处理地点分离开来，是的程序变得刻度
== 源文件和程序 ==
 *C和C++都是单独编译的
 *应该只是定义一次，到处声明使用
 *但是C和C++使用#include这种不完美的解决方法，导致了有些东西要多处定义，比如类，但是不一致也检查不出来
 *inline相当于好的宏
 *C++中从重定义C标准头文件的部分在C和C++中都有用
 *有内部链接属性和外部链接属性
 *static可表示内部链接属性，但也可表示其他含义，C中的缺陷
 *使用extern “C” 表示与非C++代码的链接
 *extern “C”{}只改变链接，不改变其他方式。比如里面的定义不会变成链接
 *命名空间影响链接，所以用extern “C” 的定义中命名空间链接时候没有效果
 *extern “C” 还影响指针类型
 *单头文件和多头文件有不同的适用场合
 *界面头文件和实现头文件分开有助于减少编译时间
 *程序初始化析构和退出的配合很复杂，有可能依赖实现
== 类 ==
 *struct相当于class只是访问类型不对
 *更新完成后返回自应用有用
 *类对象复制有默认函数
 *只有const函数才能在const变量里使用
 *虽然看起来const函数不改变对象变量的值，但是如果使用mutable关键字的话就有可能改变了。
 *也可以使用转换来将const变量转化为非const变量，但是有的实习会出错
 *具体类型和抽象类型
 *小而有效的对象提高编程效率
 *有9种对象建立的情况
 *局部变量创建以块为单位 析构顺序和生成顺序相反
 *复制初始化和复制赋值会进行对象复制，默认是按成员进行拷贝，如需要可改变语义
 *复制赋值要防止自赋值
 *类对象成员的构造是自下而上，析构是自上而下
 *成员初始化和在初始化函数里赋值是不一样的
 *类定义里只能初始化静态整形变量 只能使用产量表达式
 *对象复制使用复制赋值完成 调用函数完成
 *由于C++不区分指向单个对象的指针和指向某数组起始元素的指针 所以析构要用delete[]
 *局部静态变量将在第一次通过该对象的定义是调用
 *类定义里面的静态变量是声明
 *多编译单元静态变量的初始化就是个灾难 依赖于具体的实现
 *临时变量会在完整表达式销毁时销毁
 *可以重新定义new运行符 但是要自己搞定销毁
 *联合是不能包含析构和构造 也不能包含有析构和构造的类型
== 运算符重载 ==
 *还是编译时的游戏，没有办法定义运算符优先级
 *一元二元运算符的函数有成员函数 和 非成员函数 两种定义
 *在类型内部实现简单的操作符 在类外部使用这些简单的操作符定义复杂的操作符
 *使用转换重载来避免很多值的组合
 *用户定义的转换不会出现在. 和 ->左边
 *转换运算符重载不能声明返回 如同 构造
 *转换运算符重载 和 用户定义运算符 最好只用一个
 *转换可能产生歧义
 *友元可以访问类的内部变量
 *声明一个只有一个参数的初始化会隐式的转换 用explicit显示取消隐式转换
 *重载类的operator() 可以用于写拟函数对象
 *重载类的operator-> 可以实现灵巧指针
 *operator++()为前缀 operator++(int)为后缀
 *String对象是运算符重载的最好解释
== 派生类 ==
 *继承机制是一种有效的但是有限的方法用于重用一下代码
 *复制函数是不会继承的 因为默认会产生
 *应该避免切割
 *基类指针知道所指的对象
  *基类使用类型域 一定要避免
  *使用dynamic_cast 类型域的语言级别的支持
  *虚函数
 *虚函数 面向对象的基石
 *如果使用类型限定的话 虚函数的调用时不会使用的 因为类型已经确定 。
 *必须使用虚析构处理类继承的析构问题
 *使用抽象工厂解决类生成的依赖具体代码的问题
 *类层次结构用于构造块复用 抽象类用于界面复用
== 模板 ==
 *模板就是定义一个通用的类
 *实现技术是类似于宏
 *专门化
