= TCPL =
== 至读者 ==
 *作者本人以为C++很好
== C++ 概览 ==
 *支持编程方法
  *过程式程序设计
  *模块程序设计
   *单实例的情况下好用
  *数据抽象
   *虚函数很重要
  *面向对象程序设计
  *通用型程序设计
   *通用型容器
   *通用型算法
== 名字空间和异常 ==
 *编译依赖要尽量减少
  *4种解决方法
  *间一致性检查放到链接阶段
 *接口 和 实现 两种界面
 *名字空间用于将名字分布于不同的逻辑空间中，但是冲突会导致使用上的困难
 *名字空间定义倾向于单层次，和Java的多层次有所不同
 *使用使用指令 和 使用声明来组合和选择名字空间
 *特殊用法 无名名字空间 和 名字空间别名
 *C++的异常和Java相比没有finally关键字，也不用什么抛出什么异常
 *不知道异常是怎么实现的
 *异常将错误发生点和处理地点分离开来，是的程序变得刻度
== 源文件和程序 ==
 *C和C++都是单独编译的
 *应该只是定义一次，到处声明使用
 *但是C和C++使用#include这种不完美的解决方法，导致了有些东西要多处定义，比如类，但是不一致也检查不出来
 *inline相当于好的宏
 *C++中从重定义C标准头文件的部分在C和C++中都有用
 *有内部链接属性和外部链接属性
 *static可表示内部链接属性，但也可表示其他含义，C中的缺陷
 *使用extern “C” 表示与非C++代码的链接
 *extern “C”{}只改变链接，不改变其他方式。比如里面的定义不会变成链接
 *命名空间影响链接，所以用extern “C” 的定义中命名空间链接时候没有效果
 *extern “C” 还影响指针类型
 *单头文件和多头文件有不同的适用场合
 *界面头文件和实现头文件分开有助于减少编译时间
 *程序初始化析构和退出的配合很复杂，有可能依赖实现
== 类 ==
 *struct相当于class只是访问类型不对
 *更新完成后返回自应用有用
 *类对象复制有默认函数
 *只有const函数才能在const变量里使用
 *虽然看起来const函数不改变对象变量的值，但是如果使用mutable关键字的话就有可能改变了。
 *也可以使用转换来将const变量转化为非const变量，但是有的实习会出错
 *具体类型和抽象类型
 *小而有效的对象提高编程效率
 *有9种对象建立的情况
 *局部变量创建以块为单位 析构顺序和生成顺序相反
 *复制初始化和复制赋值会进行对象复制，默认是按成员进行拷贝，如需要可改变语义
 *复制赋值要防止自赋值
 *类对象成员的构造是自下而上，析构是自上而下
 *成员初始化和在初始化函数里赋值是不一样的
 *类定义里只能初始化静态整形变量 只能使用产量表达式
 *对象复制使用复制赋值完成 调用函数完成
 *由于C++不区分指向单个对象的指针和指向某数组起始元素的指针 所以析构要用delete[]
 *局部静态变量将在第一次通过该对象的定义是调用
 *类定义里面的静态变量是声明
 *多编译单元静态变量的初始化就是个灾难 依赖于具体的实现
 *临时变量会在完整表达式销毁时销毁
 *可以重新定义new运行符 但是要自己搞定销毁
 *联合是不能包含析构和构造 也不能包含有析构和构造的类型
== 运算符重载 ==
 *还是编译时的游戏，没有办法定义运算符优先级
